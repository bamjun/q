#!/usr/bin/env bash

json_unescape() {
  # Interpret JSON backslash escapes.
  printf '%b' "$1"
}

extract_json_value() {
  # Extract the JSON string value from a single-line "key": "value" pair.
  printf '%s\n' "$1" | sed -n 's/^[[:space:]]*"[^"]*"[[:space:]]*:[[:space:]]*"\(.*\)"[[:space:]]*,\{0,1\}[[:space:]]*$/\1/p'
}

JSON_DATA='{
  "installations": [
    {
      "name": "rustup",
      "command": "curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh"
    },
    {
      "name": "uv",
      "command": "curl -LsSf https://astral.sh/uv/install.sh | sh"
    },
    {
      "name": "homebrew(Linux|macOS)",
      "command": "curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh | bash"
    },
    {
      "name": "rclone(Linux|macOS)",
      "command": "sudo -v ; curl https://rclone.org/install.sh | sudo bash"
    },
  ]
}'

names=()
commands=()
name_set=0
cmd_set=0
current_name=""
current_command=""

while IFS= read -r line; do
  case "$line" in
    *\"name\"*)
      raw_value="$(extract_json_value "$line")"
      if [ -n "$raw_value" ]; then
        current_name="$(json_unescape "$raw_value")"
        name_set=1
      fi
      ;;
    *\"command\"*)
      raw_value="$(extract_json_value "$line")"
      if [ -n "$raw_value" ]; then
        current_command="$(json_unescape "$raw_value")"
        cmd_set=1
      fi
      ;;
  esac

  if [ "$name_set" -eq 1 ] && [ "$cmd_set" -eq 1 ]; then
    names+=("$current_name")
    commands+=("$current_command")
    current_name=""
    current_command=""
    name_set=0
    cmd_set=0
  fi
done <<< "$JSON_DATA"

total="${#names[@]}"
if [ "$total" -eq 0 ]; then
  echo "No installations found in embedded JSON data" >&2
  exit 1
fi

per_page=5
page=0
pages=$(( (total + per_page - 1) / per_page ))

print_page() {
  local start=$((page * per_page))
  local end=$((start + per_page - 1))
  local idx=0
  local display=0

  if [ "$end" -ge $((total - 1)) ]; then
    end=$((total - 1))
  fi

  printf '\nInstallations (%d/%d)\n' $((page + 1)) "$pages"
  for ((idx=start; idx<=end; idx++)); do
    display=$((idx - start + 1))
    printf ' %d) %s\n' "$display" "${names[idx]}"
  done
  printf '\n'
  printf 'n: next page, N: previous page, q: quit, 1-5: run\n'
}

read_choice() {
  if [ -t 0 ]; then
    IFS= read -r choice
    return $?
  fi

  if [ -r /dev/tty ]; then
    IFS= read -r choice < /dev/tty
    return $?
  fi

  return 1
}

while true; do
  print_page
  printf '> '
  if ! read_choice; then
    echo "No interactive input available. Run with a TTY or use: bash -c \"\$(curl -fsSL https://bamjun.github.io/q/)\"" >&2
    exit 1
  fi

  case "$choice" in
    q|Q)
      exit 0
      ;;
    n)
      if [ $((page + 1)) -lt "$pages" ]; then
        page=$((page + 1))
      else
        echo "Already at last page."
      fi
      ;;
    N)
      if [ "$page" -gt 0 ]; then
        page=$((page - 1))
      else
        echo "Already at first page."
      fi
      ;;
    [1-5])
      selection=$((page * per_page + choice - 1))
      if [ "$selection" -ge 0 ] && [ "$selection" -lt "$total" ]; then
        echo "Running: ${names[selection]}"
        echo "Command: ${commands[selection]}"
        bash -c "${commands[selection]}"
      else
        echo "Invalid selection."
      fi
      ;;
    *)
      echo "Invalid input."
      ;;
  esac
done
